Point(5, 5) * 10                // Point { x: 50, y: 50, z: 0 }
Point(5, 10).negate             // Point { x: -5, y: -10, z: 3 }

Point { x: 5, y: 10, z: 5 }

Point (5, 5, 5)
Point (5, 5)
Point (0)

let point = (1, 2, 3) to Point  // from tuple 

let (x, y, z) = point           // deconstruction

Point.parse "1,2,3"             // Point { x: 1, y: 2, z: 3 }
Point(1,2,3) to String          // "1,2,3"



// create Blob(a, stream); // identity assigned

on create(A).commited => {
  diagnostics log("commited")
}

match insert create(A) {
  | Commited => diagnostics log("commited")
  | _       => 
}

await insert(a)

// Accepted
// Commited
// Propagated


Blob.locate 100 |> open

/// block.blocks.sql ≡ select block from Blob'Blocks where blob = $0 // true

/*
for block in blob blocks {
  
}
*/


/*
        Accepted
   then Commited
   then Propagated
*/




// accessable everywhere

until delete “animating.gif” // a Deleted or Error event sometime in the future

create [ 
  Dog("Blue",  age: 7)
  Dog("Bozer", age: 4)
  Dog("Bozer", age: 4)
] and wait until Propagated

let bob    = create Human("Bob")
let linda  = create Human("Linda")
let louise = create Human("Louise")
let gene   = create Human("Gene")
let tina   = create Human("Tina")

Sibling(a, b) ≡ Sibling(b, a)

married ƒ(a, b) => Marriages where a == a && b == b || a == b && b == a |> any

create Marriage(bob, linda, authority: Californa)

create [ 
  Sibling(louise, gene)  // infers Sibling(gene, louise) 
  Sibling(louise, tina)  // infers Sibling(tina, louise) 
  Sibling(gene, tina)    // infers Sibling(tina, gene) 
] and wait until Commited

married(linda, bob)       // = true

get Sibling(louise, gene) // = Sibling(louise, gene)

get Dog("Blue").age 

let dogYears = from Dogs 
               where name like "B*"
               select age |> sum


